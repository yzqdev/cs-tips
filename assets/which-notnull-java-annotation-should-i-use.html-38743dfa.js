import{_ as t,Y as e,Z as l,a1 as n,a2 as o,a0 as s,$ as i,G as p}from"./framework-ae46ee38.js";const r={},u=i('<h1 id="我应该用哪一个-notnull注解" tabindex="-1"><a class="header-anchor" href="#我应该用哪一个-notnull注解" aria-hidden="true">#</a> 我应该用哪一个@NotNull注解?</h1><p>=== 我希望能通过注解的方式，尽量避免程序中出现空指针问题，同时既能保障代码的可读性，又能和IDE的代码检查，静态代码扫描工具结合起来。相关的注解，我看到有好多种@NotNull/@NonNull/@Nonnull，而他们彼此间又有冲突，不能共用，下面是我找到的一些注解，哪个是最好的选择呢？</p><p>1.javax.validation.constraints.NotNull</p><p>运行时进验证，不静态分析</p><p>2.edu.umd.cs.findbugs.annotations.NonNull</p><p>用于finbugs和Sonar静态分析</p><p>3.javax.annotation.Nonnull</p><p>只适用FindBugs,JSR-305不适用</p><p>4.org.jetbrains.annotations.NotNull</p><p>适用用于IntelliJ IDEA静态分析</p><p>5.lombok.NonNull</p><p>适用Lombok项目中代码生成器。不是一个标准的占位符注解.</p><p>6.android.support.annotation.NonNull</p><p>适用于Android项目的标记注解,位于support-annotations包中</p><h2 id="回答" tabindex="-1"><a class="header-anchor" href="#回答" aria-hidden="true">#</a> 回答</h2><p>我推荐用javax命名空间下的注解(虽然我喜欢Lombok和Intelij做的事情)，使用其他命名空间的注解，等于你还需要引入其他依赖。</p><p>我用javax.validation.constraints.NotNull，因为它已经在Java EE 6中定义</p><p>javax.annotation.NonNull可能直到java 8都不存在(正如Stephen指出)。其他的都不是标准的注解 .</p><p>如果注解是可扩展的，那将是一件美好的事情.你可以自己写一个<code>non-null</code>注解，然后继承上面说的这些注解。如果标准的注解不支持某个特性，你就可以在自己定义的注解里面扩展。</p>',19),c={href:"http://stackoverflow.com/questions/4963300/which-notnull-java-annotation-should-i-use",target:"_blank",rel:"noopener noreferrer"};function d(h,N){const a=p("ExternalLinkIcon");return e(),l("div",null,[u,n("p",null,[o("stackoverflow链接： "),n("a",c,[o("http://stackoverflow.com/questions/4963300/which-notnull-java-annotation-should-i-use"),s(a)])])])}const _=t(r,[["render",d],["__file","which-notnull-java-annotation-should-i-use.html.vue"]]);export{_ as default};
