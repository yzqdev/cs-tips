import{_ as d,Y as a,Z as l,a1 as e,a2 as n,a0 as t,$ as i,G as s}from"./framework-ae46ee38.js";const c={},r=i('<h1 id="wait-和sleep-的区别" tabindex="-1"><a class="header-anchor" href="#wait-和sleep-的区别" aria-hidden="true">#</a> wait()和sleep()的区别</h1><h3 id="问题" tabindex="-1"><a class="header-anchor" href="#问题" aria-hidden="true">#</a> 问题</h3><p>在线程里 <code>wait()</code> 和 <code>sleep()</code> 的区别？</p><p>我的理解是执行 <code>wait()</code> 语句后，该线程仍是运行态，并且会占用CPU，但是执行 <code>sleep()</code>后，该线程则不会占用CPU，对吗？</p><p>为什么需要 <code>sleep()</code> 和 <code>wait()</code> 两条语句：他们底层是如何实现的？</p><h3 id="回答" tabindex="-1"><a class="header-anchor" href="#回答" aria-hidden="true">#</a> 回答</h3>',6),h={href:"http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html#wait%28%29",target:"_blank",rel:"noopener noreferrer"},u=e("code",null,"wait",-1),p=e("code",null,"synchronized",-1),_={href:"http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html#notify%28%29",target:"_blank",rel:"noopener noreferrer"},v=e("code",null,"sleep",-1),m=e("code",null,"wait",-1),f=e("code",null,"notify",-1),b=e("code",null,"synchronized",-1),g=e("code",null,"synchronized",-1),w=i(`<div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Object mon = ...;
synchronized (mon) {
    mon.wait();
} 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个线程调用了 <code>wait</code>后，会进入等待状态。这时另外一个线程可以这样做：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>synchronized (mon) { mon.notify(); }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可以看到，<code>synchronized</code>锁对象，都是mon。因此，当第二个线程调用了 <code>notify()</code> 方法，第一个线程就会唤醒（假设有且仅有一个线程是被包在 <code>synchronized (mon)</code> 中且处于等待状态)。</p>`,4),y=e("code",null,"synchronized",-1),x={href:"http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html#notifyAll%28%29",target:"_blank",rel:"noopener noreferrer"},k=e("code",null,"wait",-1),z=e("code",null,"synchronized",-1),j=e("code",null,"synchronized",-1),O=i(`<p>再补充几点：</p><ul><li><p><code>wait</code> 方法由 <code>Object</code> 对象调用（例如：你可以让 <code>synchronized</code> 锁对象调用 <code>wait</code> ,如上面例子的mon.wait()）,而 <code>sleep</code> 则由线程调用。</p></li><li><p><code>wait</code> 之后，可能会伪唤醒（<code>spurious wakeups</code>）（正在waiting的线程,无故就被唤醒了，如遇到interrupted, timing out等情况）。因此，你需要多设置一些检查，如果不满足实际的运行条件，则继续等待，如下：</p></li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>synchronized {
    while (!condition) { mon.wait(); }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>当线程调用 <code>sleep</code> 时，并没有释放对象锁，而 <code>wait</code> 则释放了对象锁：</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>synchronized(LOCK) {
    Thread.sleep(1000); // LOCK is held
}
synchronized(LOCK) {
    LOCK.wait(); // LOCK is not held
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后，再小结一下：</p><ul><li><code>sleep()</code>:“我已经完成了一个时间片，<strong>在n微秒</strong>前，请不要再给我一个时间片”。这时操作系统不会让这个线程做任何事情，直到sleep时间结束。</li><li><code>wait()</code>:&quot;我已经完成了一个时间片，<strong>在其他线程调用<code>notify()</code>前</strong>，请不要再给我一个时间片）。这时操作系统不会安排这个线程继续运行，直到有人调用了<code>notify()</code></li></ul>`,7),C=e("strong",null,"stackoverflow链接：",-1),L={href:"http://stackoverflow.com/questions/1036754/difference-between-wait-and-sleep",target:"_blank",rel:"noopener noreferrer"},A=e("h3",{id:"相关问题及链接",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#相关问题及链接","aria-hidden":"true"},"#"),n(" 相关问题及链接")],-1),K={href:"http://stackoverflow.com/questions/37026/java-notify-vs-notifyall-all-over-again",target:"_blank",rel:"noopener noreferrer"},q={href:"http://ifeve.com/thread-signaling/",target:"_blank",rel:"noopener noreferrer"},B={href:"http://longdick.iteye.com/blog/453615",target:"_blank",rel:"noopener noreferrer"};function N(V,E){const o=s("ExternalLinkIcon");return a(),l("div",null,[r,e("p",null,[n("线程 在"),e("a",h,[u,t(o)]),n(" 后，可以被另一个拥有相同 "),p,n(" 对象的线程，通过调用"),e("a",_,[n("notify"),t(o)]),n("唤醒，而 "),v,n(" 不行。"),m,n(" 和 "),f,n(" 能正常执行的条件是（否则会抛异常）：多个线程的代码，都包在"),b,n("块中，并且 "),g,n(" 锁的对象需要是同一个。如下所示：")]),w,e("p",null,[n("如果有多个线程在等待（且"),y,n(" 锁对象是同一个，如上例中的mon），则可以调用"),e("a",x,[n("notifyAll"),t(o)]),n("来唤醒。但是，只有其中一个线程能抢到锁并继续执行（因为 "),k,n(" 的线程都是在 "),z,n(" 块内，需要争夺 "),j,n(" 锁）。其他的线程会被锁住，直到他们依次获得锁。")]),O,e("p",null,[C,e("a",L,[n("http://stackoverflow.com/questions/1036754/difference-between-wait-and-sleep"),t(o)])]),A,e("ol",null,[e("li",null,[e("a",K,[n("Java: notify() vs. notifyAll() all over again"),t(o)])]),e("li",null,[e("a",q,[n("线程通信"),t(o)])]),e("li",null,[e("a",B,[n("最简实例说明wait、notify、notifyAll的使用方法"),t(o)])])])])}const P=d(c,[["render",N],["__file","difference-between-wait-and-sleep.html.vue"]]);export{P as default};
